<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从PA到计算机组成原理(Ⅲ)</title>
      <link href="/2019/07/16/ProgramAssignment3/"/>
      <url>/2019/07/16/ProgramAssignment3/</url>
      
        <content type="html"><![CDATA[<p></p><h2><font color="#4169E1"> PA1 - 最简单的计算机</font> </h2><p></p><h3 id="正式开始PA之旅之前"><a href="#正式开始PA之旅之前" class="headerlink" title="正式开始PA之旅之前"></a>正式开始PA之旅之前</h3><p>读完一遍讲义后我也是一脸懵逼，一下子出现这么多新事物，谁都很难接受。</p><p>NEMU, TRM, 寄存器, 调试器…都是些什么玩意儿，还有RTFSC。说到RTFSC，我一开始就不是很清楚这个短语的意思，也不是很想了解，结果后面发现讲义里到处都是，猪脚在回答关于讲义的问题时也经常甩出这个短语，再加上对于接下来做什么没有什么头绪，使得我看到它就有点烦躁。后期操作（指完成PA）比较熟练以后，我也向问我问题的同学甩出了RTFSC<del>（勇者终成恶龙）</del>。它的意思我在<a href="https://starfurye.github.io/2019/07/12/ProgramAssignment/" target="_blank" rel="noopener">前言</a>中也提到了，其实就是“看他妈的源代码”和“看他妈的手册”(RTFM)。</p><p>可以说，在做PA之前，我是一个极不喜欢读别人写的代码的人，但并不是不屑看别人的代码，这种情况经常发生在写算法题但是多次输出错误的情况下。当我向外界求助时，坠痛苦的就是看别人写的代码，相关变量名不同，再加上别人的编程习惯可能也不是很好，一下子就懵了，而且这个效率<del>efficiency</del>就很低。结果搞了半天如果没有改正自己的代码，可能风格就变成别人的风格了。</p><p>PA强制我读了别人写的代码，不仅提高了我的知识水平，了解了C语言的更多内容（比如做了PA我才知道条件编译、位域等），还让我慢慢习惯读别人写的代码。阅读别人写的代码是一种重要的团队协作能力，我认为团队能比个人创造出更多的东西（虽然我现在还是喜欢独立思考，非常仰慕那些独立游戏作者），所以提高代码阅读能力非常重要。</p><h3 id="工作环境"><a href="#工作环境" class="headerlink" title="工作环境"></a>工作环境</h3><p>讲义中已经列出了文件组织，只有经验足够丰富的人才能够第一次看到这些东西就对整个工程框架非常清楚。因此我列举一下几个开发用的软件：</p><p></p><h4><font color="#3498DB">  Visual Studio Code </font></h4><br>因此推荐使用<a href="https://code.visualstudio.com" target="_blank" rel="noopener">vscode</a>，我认为这是微软在开发领域很值得一吹的软件。如果我将它描述为“一个跨平台的、多功能的 <font color="#8E44AD">visual studio</font> ”，你应该就知道它的强大了。具体到PA有这些优点：<p></p><ul><li>vscode支持很多语言的插件，装好C/C++智能插件以后，基本的代码高亮就不说了（vim也行），它能提供和 <font color="#8E44AD">visual studio</font> 一样的代码补全功能。</li></ul><ul><li>你会发现成熟的 C 工程使用大量的 <code>#define</code>，甚至unix编程也会这么写，比如ELF头的结构体（理论课会讲到）：</li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[EI_NIDENT];</span><br><span class="line">    <span class="keyword">uint16_t</span>      e_type;</span><br><span class="line">    <span class="keyword">uint16_t</span>      e_machine;</span><br><span class="line">    <span class="keyword">uint32_t</span>      e_version;</span><br><span class="line">    ElfN_Addr     e_entry;</span><br><span class="line">    ElfN_Off      e_phoff;</span><br><span class="line">    ElfN_Off      e_shoff;</span><br><span class="line">    <span class="keyword">uint32_t</span>      e_flags;</span><br><span class="line">    <span class="keyword">uint16_t</span>      e_ehsize;</span><br><span class="line">    <span class="keyword">uint16_t</span>      e_phentsize;</span><br><span class="line">    <span class="keyword">uint16_t</span>      e_phnum;</span><br><span class="line">    <span class="keyword">uint16_t</span>      e_shentsize;</span><br><span class="line">    <span class="keyword">uint16_t</span>      e_shnum;</span><br><span class="line">    <span class="keyword">uint16_t</span>      e_shstrndx;</span><br><span class="line">&#125; ElfN_Ehdr;</span><br></pre></td></tr></table></figure><p>  你会发现几个没见过的数据类型，其实这些数据类型本质上都是用 <code>#define</code> 定义的：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ElfN_Addr       Unsigned program address, uintN_t</span><br><span class="line">ElfN_Off        Unsigned file offset, uintN_t</span><br><span class="line">ElfN_Section    Unsigned section index, <span class="keyword">uint16_t</span></span><br><span class="line">ElfN_Versym     Unsigned version symbol information, <span class="keyword">uint16_t</span></span><br><span class="line">Elf_Byte        <span class="keyword">unsigned</span> <span class="keyword">char</span></span><br><span class="line">ElfN_Half       <span class="keyword">uint16_t</span></span><br><span class="line">ElfN_Sword      <span class="keyword">int32_t</span></span><br><span class="line">ElfN_Word       <span class="keyword">uint32_t</span></span><br><span class="line">ElfN_Sxword     <span class="keyword">int64_t</span></span><br><span class="line">ElfN_Xword      <span class="keyword">uint64_t</span></span><br></pre></td></tr></table></figure><p>  甚至有的看起来像函数的东西也是由 <code>#define</code> 定义的，PA中将会大量出现这些宏定义，一开始你会被搞得晕头转向。装了智能插件以后只需要将光标移动到不懂的语句上面，就能扒开它的外壳，清楚的看见这条语句通过宏定义展开成了什么。 </p>  <img src="/2019/07/16/ProgramAssignment3/define.png" title="Expands to..."><p>  它还能够帮你解决展开宏定义的思考题。</p><ul><li>全局搜索：有的时候讲义不会提示你它说的东西在哪个文件里，使用全局搜索就能快速定位。（比较硬核的方式是使用shell命令，但只有足够熟练才能达到和工具差不多的效果）</li></ul><ul><li>语法检查：如果C语言不够熟练，可以在编译以前发现错误。</li></ul><p>如果你是个巨佬，认为这不够硬核，使用工具是弱者的行为，那么你可以直接在shell里完成PA。</p><h3 id="虚拟机？模拟器？"><a href="#虚拟机？模拟器？" class="headerlink" title="虚拟机？模拟器？"></a>虚拟机？模拟器？</h3><p>虚拟机和模拟器本质差不多，都是用软件调用系统资源来模拟虚拟的硬件设备。<br>但是，模拟器是通常模拟不同的指令集、不同体系架构的 CPU，多数情况要对微指令进行解释执行，或利用即时编译技术进行加速，才能勉强得到可用的速度。<br>虚拟机大多模拟一套相同指令集相同架构的硬件平台，因此在做好保护的前提下，很多时候可以直接利用 CPU 去执行目标指令。虽然还是模拟物理 CPU 而不借助于主机操作系统的功能，但少了一层指令集转换，运行速度提高不少。<br>如iOS和Android模拟器，通常不叫做iOS或Android虚拟机，因为x86和ARM的指令集架构不同。</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ics(Introduction to computer systems) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从PA到计算机组成原理(Ⅱ)</title>
      <link href="/2019/07/14/ProgramAssignment2/"/>
      <url>/2019/07/14/ProgramAssignment2/</url>
      
        <content type="html"><![CDATA[<h2><font color="#4169E1"> PA0 - 开发环境配置</font> </h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>在做PA之前需要做好充足的准备，这便是PA0的存在意义。</p><p>一开始读讲义，猪脚会吓唬大家讲义都是用英文编写的，但其实仅限于PA0（暂时？），后面的讲义都还是用中文编写的。</p><p>PA的环境是Debian(Linux)，如果平时接触过python，就会发现，在Windows下安装python很麻烦，即便装好了，在运行某些程序的时候也会抛出一些神秘的错误，还很难解决。但在Unix/Linux中甚至都不需要安装python，这是因为后者一般本来就有python这一“程序”，比如各个发行版的包管理器都需要python的支持。此外，后者还包含了python的所有底层模块，缺失这些模块也是前面提到的神秘错误的来源。</p><p>Nuaa使用virtual box，而nju使用docker。</p><h3 id="网络配置（有线宽带）"><a href="#网络配置（有线宽带）" class="headerlink" title="网络配置（有线宽带）"></a>网络配置（有线宽带）</h3><p>一般情况下按讲义上的配置就可以了，但我做的时候出现了问题，无法使用ssh，这意味着主机和虚拟机间的文件传输无法进行，除此之外也不能使用x11转发功能，这个功能在PA中很重要。</p><p>寒假在家做的时候连的是家里的路由器，因此选的是桥接模式:<code>Bridged Adapter</code>。而我在学校用的是<strong>有线</strong>宽带，即便换成NAT也不管用，于是我就花了一个下午时间去解决这个问题，相关解决方案如下：</p><p>选择使用 <code>ip addr</code> 命令后，可能会看到如下信息：</p><img src="/2019/07/14/ProgramAssignment2/LAN.PNG" title="注意圈出的部分"><p><code>10.0.2.15</code> 表示的意思就是虚拟机和主机存在于同一个局域网内，因此在putty中要填的ip就应该是<strong>主机的ip</strong>，可以打开cmd或者powershell再输入ipconfig查看，我用的是有线宽带，因此就看PPPoE这一项，<strong>记下这个ip</strong>。</p><p>填好了ip，那么端口怎么办呢？在了解了主机和虚拟机之间的网络关系后，又如何在局域网内进行通信呢？答案是通过<strong>端口转发</strong>，我们可以用如下的示意图表示：</p><img src="/2019/07/14/ProgramAssignment2/Ports.png" title="端口"><p>我们需要填写两个端口：主机端口和虚拟机端口，就像寄信需要填写发出和接收地址一样。</p><p>虚拟机端口默认为22——这是Linux默认的ssh端口。主机端口可以选择除了以下<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers" target="_blank" rel="noopener">常用端口</a>以外的端口。</p><p>在Virtual Box的网络选项卡下选择nat，下边有一个tab叫做Port Forwarding(端口转发)，如下图设置：</p><img src="/2019/07/14/ProgramAssignment2/PortForwarding.PNG" title="端口转发"><p>注意在putty和filezilla中设置的端口号是主机端口号：</p><img src="/2019/07/14/ProgramAssignment2/putty.PNG" title="putty设置"><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>具体可以看我之前写的<a href="https://starfurye.github.io/2019/02/03/gitLearning/" target="_blank" rel="noopener">这篇</a>，但只能作为手册查询，如果对于git一无所知，参考讲义上的git帮助。</p><h3 id="X-Server"><a href="#X-Server" class="headerlink" title="X Server"></a>X Server</h3><p>PA中采用X server来显示图形，其原型是<a href="https://en.wikipedia.org/wiki/X_Window_System" target="_blank" rel="noopener">X Window System</a>(X)。它是一个用于位图显示的图形系统，为GUI提供了一个基本的框架，但<strong>没有提供用户交互</strong>，因此不同的程序使用有不同的X界面。</p><p>值得注意的是，X本来就被设计为在网络连接下工作，并且具有网络透明性。这使得计算机A上运行的X程序能在某个网络下，通过计算机B上运行的X server来显示A的图形界面。而X Server提供了诸如键盘鼠标事件的图形资源。这意味着运行<strong>X server</strong>的计算机才用于人机交互，而<strong>X程序</strong>可以在同一网络内的任意计算机上运行。</p><blockquote><p>网络<strong>透明性</strong>是什么意思？</p><p>我们知道很多例子：为了开发的方便和安全，计算机底层细节对于应用程序员来说是<strong>透明</strong>的；特权指令对于一般的系统程序员也是透明的；应用程序接口（API）的实现细节对于应用程序员也具有透明性。</p><p>网络透明性使得我们可以直接使用通过网络传输来的信息，而无需了解传输过程和细节。</p></blockquote><p>如下图所示：</p><img src="/2019/07/14/ProgramAssignment2/XServer.png"><p>我们在putty中利用ssh运行<code>xclock</code>时，实际上就将虚拟机作为运行X程序的计算机A，而Xming之类的程序提供的则是运行X server的计算机B。后面运行键盘测试时我们应该在Xming的图形界面上敲键盘，而不是在putty或者Virtual Box的界面上敲键盘。</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ics(Introduction to computer systems) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从PA到计算机组成原理(Ⅰ)</title>
      <link href="/2019/07/12/ProgramAssignment/"/>
      <url>/2019/07/12/ProgramAssignment/</url>
      
        <content type="html"><![CDATA[<h2><font color="#4169E1">前言&杂谈</font> </h2><p>大二下学习了计算机组成原理这门课，学院给信息安全和软件工程专业安排的配套课程设计是PA(Programming Assignment)。简单来说，PA要做的事就是<strong>用代码</strong>(C &amp; assembly)<strong>来模拟一台计算机</strong>，实现一个x86架构的子集。</p><p>做完以后我认为有必要为它写一篇总结，有以下几个原因：</p><ul><li><p>纪念：也许对于很多人来说PA只不过是一个普普通通的<del>或者更恶心的</del>课设罢了。我们从寒假做到暑假，每周末都要花上十几个小时，再加上周内晚上花的时间，还有几次猪脚上课的时间，和某些专业的到实验室辛苦一两天就能完成的课设相比，哪个更累是显而易见的。</p><p>然而到最后加起来也<strong>只不过</strong>写了1k来行代码，而数据结构课设少说也有3k+的代码量，那么看似效率如此之低又折磨人的课设岂不是做完就可以 <code>rm -rf *</code> 了呢？<del>不是，直接删虚拟机就可以了（滑稽）</del> </p><img src="/2019/07/12/ProgramAssignment/codeline.jpg" title="PA每个阶段代码行数"><p>恰恰相反，我想解释一下这部分的时间组成，如果说听助教上课的时间占1%的话，那么写代码的时间就占了2%，看框架的时间有35%，调试时间有60%，剩下的时间用于发呆、无能狂怒等。</p><p>花了这么多时间来做PA，收获也很大（至少对我来说）。PA首先是对理论课的补充，比如，第三章学到的一大堆指令，光看书可能没有什么印象，但是在PA2中将会一个一个实现这些指令，虽然课程没有要求手写汇编代码，但做了PA后会对这些指令的细节非常清楚，再结合bomblab，你会发现自己厉害了许多。再比如分页机制、异常处理和IO，分页是理论课的难点，异常处理理论课讲的很少，IO甚至不讲（老师说后面微机原理课会详细讲）。</p><p>做完PA后，你会对计算机有一个整体的认识，虽然这可能只是一个模糊的轮廓，但对于将来的发展会很有好处。PA还会带你认识一个新的C，在回顾的同时学习新的内容并且<del>再次陷入指针的泥沼</del>强化对于指针的认识，你会惊讶：原来C还可以这样！</p><p>除了学习方面外，PA不仅训练了我 RTFSC(Read the Fucking Source Code) 和 RTFM(Read the Fucking Manual) 的能力，还培养了我的调试能力，对于意志力也是一种训练。所以我认为值得纪念。</p></li><li><p>回顾和复习：计算机组成原理作为计算机专业四大基础课之一，经常复习大有裨益。但我要在这里揭示一个真相，我们两个专业学的计算机组成原理其实不是真的“组成原理”，或者从内容范围上来说，只是皮毛，对于硬件部分的内容涉及极少而且老师上课时还可能一笔带过。但考研这些部分是要考的，真正要学还是得去看CSAPP（见参考书目）。</p></li><li><p>因为期末时间比较紧，我没有在PA4的报告里写整体的感想，但我写了会整理到博客。<del>如果看我报告的猪脚能看到就好了…</del></p></li></ul><p>虽然投入了很多时间，但大家做的依旧是一个简化了的PA，难度其实没有以前的版本大，但内容对于一门有限时间的大学课程来说足够了。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ol><li><p>这几篇文章是以我的观点来看PA，只是经验谈，和讲义不一样。而我已经做完过PA，因此某些坑我也跳过，但是这些绝大部分的坑讲义上<strong>没有提及</strong>，也就是说，猪脚想让同学们享受一下跳坑再爬出的快乐。我会在后面几篇文章里列出原因和解决方法，但实际上我不可能遇到所有的坑，做PA的时候有些同学在课程群里发的错误截图我也不太明白原因，所以我<strong>仅</strong>能对我以前碰到过的坑进行说明。</p></li><li><p>后面几篇文章的原则是详细给出思路，但没有全部的源代码，我会将自己第一次做的时候的几个疑问和我对于代码、讲义的理解记录下来。</p></li><li><p>我没有选择做助教，但我尊重自己过去的选择。我认为一年后自己有更多的事情去做，但写这几篇文章也表达出了相同的目的：强化这部分的记忆，因为作为基础，再怎么强调也不为过。</p></li></ol><h3 id="本文基于的讲义-url"><a href="#本文基于的讲义-url" class="headerlink" title="本文基于的讲义(url)"></a>本文基于的讲义(url)</h3><p>2019NUAA:    <code>https://www.jinhangdev.cn/ics/text/</code></p><p>NJU-ics2017:    <code>https://nju-ics.gitbooks.io/ics2017-programming-assignment/content/</code></p><h3 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h3><ul><li><p>《深入理解计算机系统（第2/3版）》(<em>Computer Systems - A Programmer’s Perspective, CSAPP</em>)</p></li><li><p>理论课教材：《计算机系统基础（第2版）》(<em>Introduction to Computer Systems</em>)，机械工业出版社</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ics(Introduction to computer systems) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bash - communicating with Miss UNIX</title>
      <link href="/2019/04/18/bash/"/>
      <url>/2019/04/18/bash/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Bash is the shell, or command language interpreter, for the gnu operating system. The name is an acronym for the <em>‘Bourne-Again SHell’</em>, a pun on Stephen Bourne, the author of the direct ancestor of the current Unix shell sh, which appeared in the Seventh Edition Bell Labs Research version of Unix.</p></blockquote><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="What-is-a-shell"><a href="#What-is-a-shell" class="headerlink" title="What is a shell?"></a>What is a shell?</h3><p>At its base, a shell is simply a <em>macro processor</em> that executes commands. The term macro processor means functionality where text and symbols are expanded to create larger expressions.</p><p>A Unix shell is both a command interpreter and a programming language.</p><p>Shells may be used interactively or non-interactively. In interactive mode, they accept input typed from the keyboard. When executing non-interactively, shells execute commands read from a file.</p><p>A shell allows execution of gnu commands, both synchronously and asynchronously. The shell waits for synchronous commands to complete before accepting more input; asynchronous commands continue to execute in parallel with the shell while it reads and executes additional commands. The <em>redirection</em> constructs permit fine-grained control of the input and output of those commands. Moreover, the shell allows control over the contents of commands’ environments.</p><p>Shells also provide a small set of built-in commands (builtins) implementing functionality impossible or inconvenient to obtain via separate utilities. For example, <code>cd</code>, <code>break</code>, <code>continue</code>, and <code>exec</code> cannot be implemented outside of the shell because they directly manipulate the shell itself. The <code>history</code>, <code>getopts</code>, <code>kill</code>, or <code>pwd</code> builtins, among others, could be implemented in separate utilities, but they are more convenient to use as builtin commands. All of the shell builtins are described in subsequent sections.</p><p>Shell 提供了小部分内建功能，部分功能在其它程序中可能无法使用。比如：<code>cd</code>, <code>break</code>, <code>continue</code>, <code>exec</code> 不能在 shell 外部使用，因为它们使用的是 shell 本身；<code>history</code>, <code>getopts</code>, <code>kill</code>, <code>pwd</code> 则可以在别的程序中使用，但即便如此，在 shell 中使用他们会更加方便。</p><p>While executing commands is essential, most of the power (and complexity) of shells is due to their embedded programming languages. Like any high-level language, the shell provides variables, flow control constructs, quoting, and functions.<br>Shell 内嵌的编程语言非常强大，她提供了变量、控制流、引用和函数等高级语言具有的特性。</p><p>Shells offer features geared specifically for interactive use rather than to augment the programming language. These interactive features include job control, command line editing, command history and aliases.<br>相比作为一种编程语言，shell 多用于交互，她包括了工作控制、命令行编辑等特点。</p><h2 id="Definitions-定义解释"><a href="#Definitions-定义解释" class="headerlink" title="Definitions 定义解释"></a>Definitions 定义解释</h2><div class="table-container"><table><thead><tr><th style="text-align:center">name</th><th style="text-align:center">description</th></tr></thead><tbody><tr><td style="text-align:center"><strong>POSIX</strong></td><td style="text-align:center">A family of open system standards based on Unix. Bash is primarily concerned with the Shell and Utilities portion of the posix 1003.1 standard.</td></tr><tr><td style="text-align:center"><strong>blank</strong></td><td style="text-align:center">A space or tab character.</td></tr><tr><td style="text-align:center"><strong>builtin</strong></td><td style="text-align:center">A command that is implemented internally by the shell itself, rather than by an executable program somewhere in the file system.（shell 内建的命令。）</td></tr><tr><td style="text-align:center"><strong>control operator</strong></td><td style="text-align:center">A token that performs a control function. It is a newline or one of the following: &#124;&#124;, &#38;&#38;;, &#38;, ;, ;;, ;&#38;, ;;&#38;, &#124;, &#124;&amp;, (, or ).</td></tr><tr><td style="text-align:center"><strong>exit status</strong></td><td style="text-align:center">The value returned by a command to its caller. The value is restricted to eight bits, so the maximum value is 255. 命令返回给调用者的值，该值被限制为八位，即其最大值为255。</td></tr><tr><td style="text-align:center"><strong>field</strong></td><td style="text-align:center">A unit of text that is the result of one of the shell expansions. After expansion, when  executing a command, the resulting fields are used as the command name and arguments.</td></tr><tr><td style="text-align:center"><strong>filename</strong></td><td style="text-align:center">A string of characters used to identify a file.</td></tr><tr><td style="text-align:center"><strong>job</strong></td><td style="text-align:center">A set of processes comprising a pipeline, and any processes descended from it, that are all in the same process group.</td></tr><tr><td style="text-align:center"><strong>job control</strong></td><td style="text-align:center">A mechanism by which users can selectively stop (suspend) and restart (resume) execution of processes.</td></tr><tr><td style="text-align:center"><strong>metacharacter</strong></td><td style="text-align:center">A character that, when unquoted, separates words. A metacharacter is a <em>space</em>, <em>tab</em>, <em>newline</em>, or one of the following characters: &#124;, &#38;, ;, (, ), &#60;, or &#62;.</td></tr><tr><td style="text-align:center"><strong>元字符</strong></td><td style="text-align:center">在不带引号时可以用于分离词，可以是空格，制表符，换行或者&#124;, &#38;, ;, (, ), &#60;, &#62;。</td></tr><tr><td style="text-align:center"><strong>name（标识符）</strong></td><td style="text-align:center">A word consisting solely of letters, numbers, and underscores, and beginning with a letter or underscore. Names are used as shell variable and function names. Also referred to as an identifier. （由字母、数字和下划线组成，以字母或下划线开头的词，常用于 shell 变量和函数名。）</td></tr><tr><td style="text-align:center"><strong>operator</strong></td><td style="text-align:center">A control operator or a redirection operator. 控制符或重定向符</td></tr><tr><td style="text-align:center"><strong>process group（进程组）</strong></td><td style="text-align:center">A collection of related processes each having the same process group id. （一组相关的进程，具有相同的进程组id。）</td></tr><tr><td style="text-align:center"><strong>process group ID</strong></td><td style="text-align:center">A unique identifier that represents a process group during its lifetime. （在进程组的生命周期中，用于唯一标识该进程组的标识符。）</td></tr><tr><td style="text-align:center"><strong>reserved word</strong></td><td style="text-align:center">A word that has a special meaning to the shell. Most reserved words introduce shell flow control constructs, such as <code>for</code> and <code>while</code>. （具有特殊含义的词，多用于控制流结构，如 <code>for</code>, <code>while</code>。）</td></tr><tr><td style="text-align:center"><strong>return status</strong></td><td style="text-align:center">A synonym for exit status.</td></tr><tr><td style="text-align:center"><strong>signal（信号）</strong></td><td style="text-align:center">A mechanism by which a process may be notified by the kernel of an event occurring in the system. （使得进程在运行时能被内核通知的机制。）</td></tr><tr><td style="text-align:center"><strong>special builtin</strong></td><td style="text-align:center">A shell builtin command that has been classified as special by the posix standard.</td></tr><tr><td style="text-align:center"><strong>token（句柄)</strong></td><td style="text-align:center">A sequence of characters considered a single unit by the shell. It is either a word or an operator. （在一条句子中被 shell 认为有意义的最小部分，可以是一个词或一个运算符。）</td></tr><tr><td style="text-align:center"><strong>word</strong></td><td style="text-align:center">A sequence of characters treated as a unit by the shell. Words may not include unquoted metacharacters.（一段被 shell 作为单个单元处理的字符，不能包括未带引号的元字符。）</td></tr></tbody></table></div><h2 id="Basic-Shell-Features-基本的-shell-特性"><a href="#Basic-Shell-Features-基本的-shell-特性" class="headerlink" title="Basic Shell Features 基本的 shell 特性"></a>Basic Shell Features 基本的 shell 特性</h2><p>This chapter briefly summarizes the shell’s ‘building blocks’: commands, control structures, shell functions, shell parameters, shell expansions, redirections, which are a way to direct input and output from and to named files, and how the shell executes commands.</p><p>本章简要地介绍 shell 被用于向文件输入输出的内建模块：命令、控制结构、函数、参数、扩展和重定向，以及解释 shell 如何执行命令。</p><h3 id="Shell-Syntax-Shell-语法"><a href="#Shell-Syntax-Shell-语法" class="headerlink" title="Shell Syntax Shell 语法"></a>Shell Syntax Shell 语法</h3><p>When the shell reads input, it proceeds through a sequence of operations. If the input indicates the beginning of a comment, the shell ignores the comment symbol (‘#’), and the rest of that line. </p><p>Otherwise, roughly speaking, the shell reads its input and divides the input into words and operators, employing the quoting rules to select which meanings to assign various words and characters. </p><p>The shell then parses these tokens into commands and other constructs, removes the special meaning of certain words or characters, expands others, redirects input and output as needed, executes the specified command, waits for the command’s exit status, and makes that exit status available for further inspection or processing. </p><h4 id="Shell-Operation"><a href="#Shell-Operation" class="headerlink" title="Shell Operation"></a>Shell Operation</h4><p>The following is a brief description of the shell’s operation when it reads and executes a command. Basically, the shell does the following:</p><ol><li><p>Reads its input from a file, from a string supplied as an argument to the -c invocation option, or from the user’s terminal. </p></li><li><p>Breaks the input into words and operators, obeying the quoting rules. These tokens are separated by metacharacters. Alias expansion is performed by this step.</p></li><li>Parses the tokens into simple and compound commands. </li><li>Performs the various shell expansions, breaking the expanded tokens into lists of filenames and commands and arguments. </li><li>Performs any necessary redirections and removes the redirection operators and their operands from the argument list. </li><li>Executes the command. </li><li>Optionally waits for the command to complete and collects its exit status.  </li></ol><h4 id="Quoting-引用"><a href="#Quoting-引用" class="headerlink" title="Quoting 引用"></a>Quoting 引用</h4><p>Quoting is used to remove the special meaning of certain characters or words to the shell. Quoting can be used to disable special treatment for special characters, to prevent reserved words from being recognized as such, and to prevent parameter expansion. </p><p>引用常被用于消歧义，移除保留字的特殊意义（转义）等。</p><p>Each of the shell metacharacters has special meaning to the shell and must be quoted if it is to represent itself. When the command history expansion facilities are being used, the history expansion character, usually ‘!’, must be quoted to prevent history expansion. </p><p>shell 中有三种引用机制：反斜杠、单引号和双引号。</p><h5 id="Escape-Character-反斜杠"><a href="#Escape-Character-反斜杠" class="headerlink" title="Escape Character 反斜杠"></a>Escape Character 反斜杠</h5><p>A non-quoted backslash ‘\’ is the Bash escape character. It preserves the literal value of the next character that follows, with the exception of newline. If a \newline pair appears, and the backslash itself is not quoted, the \newline is treated as a line continuation (that is, it is removed from the input stream and effectively ignored).</p><p>未引用的反斜杠将被用于转义，除了一种特殊情况：若反斜杠后跟换行符，将被视为该行的继续（也就是说，在输入流中，反斜杠会被移除）。</p><h5 id="Single-Quotes-单引号"><a href="#Single-Quotes-单引号" class="headerlink" title="Single Quotes 单引号"></a>Single Quotes 单引号</h5><p>Enclosing characters in single quotes (‘’’) preserves the literal value of each character within<br>the quotes. A single quote may not occur between single quotes, even when preceded by a<br>backslash.</p><h5 id="Double-Quotes-双引号"><a href="#Double-Quotes-双引号" class="headerlink" title="Double Quotes 双引号"></a>Double Quotes 双引号</h5><p>Enclosing characters in double quotes (‘<code>&quot;</code>’) preserves the literal value of all characters within<br>the quotes, with the exception of ‘<code>$</code>’, ‘<code>‘</code>’, ‘<code>\</code>’, and, when history expansion is enabled, ‘<code>!</code>’.</p><ul><li><p>When the shell is in <code>posix</code> mode, the ‘<code>!</code>’ has no special meaning within double quotes, even when history expansion is enabled.</p></li><li><p>The characters ‘<code>$</code>’ and ‘<code>‘</code>’ retain their special meaning within double quotes.</p></li><li><p>The backslash retains its special meaning only when followed by one of the following characters: ‘<code>$</code>’, ‘<code>‘</code>’, ‘<code>&quot;</code>’, ‘<code>\</code>’, or <code>newline</code>. Within double quotes, backslashes that are followed by one of these characters are removed. Backslashes preceding characters without a special meaning are left unmodified.</p></li><li><p>A double quote may be quoted within double quotes by preceding it with a backslash. If enabled, history expansion will be performed unless an ‘<code>!</code>’ appearing in double quotes is escaped using a backslash. The backslash preceding the ‘<code>!</code>’ is not removed. </p></li><li><p>The special parameters ‘<code>*</code>’ and ‘<code>@</code>’ have special meaning when in double quotes, (see [Shell Parameter Expansion]). </p></li></ul><h5 id="ANSI-C-Quoting-ANSI-C引用"><a href="#ANSI-C-Quoting-ANSI-C引用" class="headerlink" title="ANSI-C Quoting ANSI-C引用"></a>ANSI-C Quoting ANSI-C引用</h5>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cypher</title>
      <link href="/2019/04/10/Cypher/"/>
      <url>/2019/04/10/Cypher/</url>
      
        <content type="html"><![CDATA[<h2 id="Prologue"><a href="#Prologue" class="headerlink" title="Prologue"></a>Prologue</h2><p>Cypher begins with a section, it’s from <em>Alice’s Adventures in Wonderland</em>, </p><img src="/2019/04/10/Cypher/Firstpuzzle.jpg" title="First puzzle in Cypher">]]></content>
      
      
      <categories>
          
          <category> miscellaneous </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Game review </tag>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My gitlearning notes</title>
      <link href="/2019/02/03/gitLearning/"/>
      <url>/2019/02/03/gitLearning/</url>
      
        <content type="html"><![CDATA[<h2 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><ol><li>选择一个合适的目录（最好是空目录），通过<code>git init</code>将其变为Git可以管理的仓库：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>其中<code>.git</code>目录是Git用于跟踪管理版本库的，<strong>没事千万不要手动修改这个目录里的文件</strong>。</p><ol><li>用<code>git add</code>将文件添加到仓库：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><ol><li>用<code>git commit -m &lt;message&gt;</code>将文件提交到仓库：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"wrote a readme file"</span></span><br></pre></td></tr></table></figure><p><code>-m</code>后面输入本次提交的说明，<code>commit</code>一次可以提交很多文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m <span class="string">"add 3 files."</span></span><br></pre></td></tr></table></figure><h3 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h3><ul><li>随时掌握工作区状态，使用<code>git status</code>命令</li><li>如果<code>git status</code>告诉你文件被修改过，用<code>git diff</code>查看修改内容</li></ul><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><ul><li><code>git log</code>查看版本历史记录，如果觉得输出信息太多，加上<code>--pretty=oneline</code></li><li><code>HEAD</code>是一个指向当前版本的指针，<code>HEAD</code>表示当前版本，<code>HEAD^</code>表示上一个版本，<code>HEAD^^</code>表示上上个版本…<code>HEAD-100</code>表示前100个版本</li><li><code>git reset</code>回退：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>回退到了上个版本，若要撤销这次更改，返回到原来的版本，需要知道那个版本的<code>commit id</code>（的前几位），<strong>最后的办法</strong>是查询Git记录的命令，利用<code>git reflog</code>查找那个版本的<code>commit id</code>。</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><ul><li>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- &lt;filename&gt;</code>。</li><li>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;filename&gt;</code>，再使用<code>git checkout -- &lt;filename&gt;</code>。</li><li>已经提交了不合适的修改到版本库时，想要撤销本次提交，参考上一节，不过前提是没有推送到远程库。</li></ul><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>若使用<code>rm</code>在文件管理器中删除了文件，有以下两种情况：</p><ul><li>确实需要删除这个文件，那么使用<code>git rm &lt;filename&gt;</code>在暂存区内把文件删去，然后<code>git commit</code>。</li><li>卧槽，删错了，见上一节，<code>git checkout -- &lt;filename&gt;</code>撤销修改。</li></ul><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><p>如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>关联远程库，使用<code>git remote add &lt;repositoryname&gt; git@server-name:path/repo-name.git</code>（详情见Github提示，库名默认为<code>origin</code>）。</p><p>关联后，使用命令<code>git push -u origin master</code><strong>第一次</strong>推送<code>master</code>分支的所有内容，此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改，其中，<code>origin</code>是默认的库名。</p><h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><p>使用<code>git clone</code>命令克隆，Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git</code>协议速度最快。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p><code>HEAD</code>严格来说并不是指向提交，而是指向当前分支，<code>master</code>才指向提交。不同的人在进行同一个项目的开发时，需要建立分支，工作完成后，就需要把分支合并到<code>master</code>上，Git的合并和删除分支实质上就是指针的修改和删除。</p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><ul><li>使用<code>git checkout -b &lt;branchname&gt;</code>创建并切换到分支。它相当于：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch &lt;branchname&gt;</span><br><span class="line">$ git checkout &lt;branchname&gt;</span><br></pre></td></tr></table></figure><ul><li>使用<code>git branch</code>查看所有分支，当前分支的前面会有一个星号*。</li><li>使用<code>git checkout &lt;branchname&gt;</code>切换分支。</li><li>使用<code>git merge &lt;branchname&gt;</code>将要合并的分支合并到<code>master</code>分支上。</li><li>使用<code>git branch -d &lt;branchname&gt;</code>删除分支</li><li>当Git无法自动合并分支时，就必须首先解决冲突，将冲突的文件<strong>统一</strong>修改为我们希望的内容，然后提交。解决冲突的步骤是：查看冲突文件（<code>cat &lt;filename&gt;</code>，Git会给予提示），编辑冲突文件（Git已在冲突文件中写入改动情况），提交，最后删去非<code>master</code>的分支。</li><li>使用<code>git log --graph</code>查看合并分支图。使用<code>git log --graph --pretty=oneline --abbrev-commit</code>更方便查看。</li></ul><h3 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h3><p>合并分支时，加上<code>--no-ff</code>就可以用普通模式合并，合并后存在历史分支，而Git默认的<code>fast forward</code>会删去历史分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m <span class="string">"something"</span> &lt;branchname&gt;</span><br></pre></td></tr></table></figure><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本。每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p><h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p>手头工作没有完成却要先到别的分支（修复bug时，一般要创建新的<code>issue-xxx</code>分支）上工作时，使用<code>git stash</code>，再切换到别的分支工作，工作结束后，通过<code>git stash pop</code>恢复stash内容并删除原来的stash内容。若不想删去stash内容，使用<code>git stash apply stash@{number}</code>，日后再通过<code>git stash drop</code>删除。<code>git stash pop</code>和<code>git stash drop</code>删除的都是最新的一个stash。</p><p>通过<code>git stash list</code>查看stash 内容。</p><h3 id="feature分支"><a href="#feature分支" class="headerlink" title="feature分支"></a>feature分支</h3><p>开发一个新的feature，最好新建一个分支，如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin &lt;branchname&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branchname&gt; origin/&lt;branchname&gt;</code>。</p><ul><li>查看远程库，使用<code>git remote -v</code>；</li><li>本地新建的分支如果不推送到远程，对他人就是不可见的；</li><li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li><li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li></ul><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p><code>git rebase</code>可以把本地未push的分叉提交历史管理整理成直线，目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。缺点是本地的分叉提交已经被修改过了。</p><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针，标签是一个让人容易记住的名字（如版本号v1.0），而不是像<code>commit id</code>一样的字符串。</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><ul><li><code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认commit为<code>HEAD</code>，也可以用<code>commit id</code>指定一个commit。</li><li>命令<code>git tag -a &lt;tagname&gt; -m &quot;something...&quot;</code>可以指定标签信息；</li><li>命令<code>git tag</code>可以查看所有标签，<code>git show &lt;tagname&gt;</code>查看标签信息。</li></ul><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><ul><li><code>git push origin &lt;tagname&gt;</code>推送一个本地标签；</li><li><code>git push origin --tags</code>推送全部未推送过的本地标签；</li><li><code>git tag -d &lt;tagname&gt;</code>删除一个本地标签；</li><li><code>git push origin :refs/tags/&lt;tagname&gt;</code>删除一个远程标签。</li></ul><h2 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h2><p>在GitHub上，可以点击<strong>Fork</strong>，这样会在自己的账号下克隆一个相同的仓库，然后通过<code>git clone</code>命令从<strong>自己的</strong>仓库里克隆项目——只有这样才有权限进行读写，然后就可以开始工作。工作结束后，往自己的仓库推送。如果你参与的是别人的项目，可以在GitHub上发起一个<code>pull request</code>。</p><h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global color.ui <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这样，Git会适当地显示不同的颜色。</p><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p>忽略某些文件时，需要加入<code>.gitignore</code>并提交，不需要自己从头编写，可以到以下网站查找：</p><blockquote><p><a href="https://www.gitignore.io/" target="_blank" rel="noopener">https://www.gitignore.io/</a><br><a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p></blockquote><p>检验<code>.gitignore</code>是否符合你的需要的标准是<code>git status</code>命令下是否显示<code>working directory clean</code>。</p><p>忽略文件的原则是：</p><ul><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ul><p>若想添加一个文件到Git，而这个文件却已经被<code>.gitignore</code>忽略，可以强制添加：<code>git add -f &lt;filename&gt;</code>；另一种情况是，<code>.gitignore</code>确实写的有问题，可以用<code>git check-ignore -v &lt;filename&gt;</code>检查该文件。</p><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p><p>每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config </span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = <span class="literal">true</span></span><br><span class="line">    bare = <span class="literal">false</span></span><br><span class="line">    logallrefupdates = <span class="literal">true</span></span><br><span class="line">    ignorecase = <span class="literal">true</span></span><br><span class="line">    precomposeunicode = <span class="literal">true</span></span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">    url = git@github.com:michaelliao/learngit.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">    last = <span class="built_in">log</span> -1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。<br>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitconfig</span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">    co = checkout</span><br><span class="line">    ci = commit</span><br><span class="line">    br = branch</span><br><span class="line">    st = status</span><br><span class="line">[user]</span><br><span class="line">    name = Your Name</span><br><span class="line">    email = your@email.com</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p><h3 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h3><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
