<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>bash - communicating with Miss UNIX</title>
      <link href="/2019/04/18/bash/"/>
      <url>/2019/04/18/bash/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Bash is the shell, or command language interpreter, for the gnu operating system. The name is an acronym for the <em>‘Bourne-Again SHell’</em>, a pun on Stephen Bourne, the author of the direct ancestor of the current Unix shell sh, which appeared in the Seventh Edition Bell Labs Research version of Unix.</p></blockquote><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="What-is-a-shell"><a href="#What-is-a-shell" class="headerlink" title="What is a shell?"></a>What is a shell?</h3><p>At its base, a shell is simply a <em>macro processor</em> that executes commands. The term macro processor means functionality where text and symbols are expanded to create larger expressions.</p><p>A Unix shell is both a command interpreter and a programming language.</p><p>Shells may be used interactively or non-interactively. In interactive mode, they accept input typed from the keyboard. When executing non-interactively, shells execute commands read from a file.</p><p>A shell allows execution of gnu commands, both synchronously and asynchronously. The shell waits for synchronous commands to complete before accepting more input; asynchronous commands continue to execute in parallel with the shell while it reads and executes additional commands. The <em>redirection</em> constructs permit fine-grained control of the input and output of those commands. Moreover, the shell allows control over the contents of commands’ environments.</p><p>Shells also provide a small set of built-in commands (builtins) implementing functionality impossible or inconvenient to obtain via separate utilities. For example, <code>cd</code>, <code>break</code>, <code>continue</code>, and <code>exec</code> cannot be implemented outside of the shell because they directly manipulate the shell itself. The <code>history</code>, <code>getopts</code>, <code>kill</code>, or <code>pwd</code> builtins, among others, could be implemented in separate utilities, but they are more convenient to use as builtin commands. All of the shell builtins are described in subsequent sections.</p><p>Shell 提供了小部分内建功能，部分功能在其它程序中可能无法使用。比如：<code>cd</code>, <code>break</code>, <code>continue</code>, <code>exec</code> 不能在 shell 外部使用，因为它们使用的是 shell 本身；<code>history</code>, <code>getopts</code>, <code>kill</code>, <code>pwd</code> 则可以在别的程序中使用，但即便如此，在 shell 中使用他们会更加方便。</p><p>While executing commands is essential, most of the power (and complexity) of shells is due to their embedded programming languages. Like any high-level language, the shell provides variables, flow control constructs, quoting, and functions.<br>Shell 内嵌的编程语言非常强大，她提供了变量、控制流、引用和函数等高级语言具有的特性。</p><p>Shells offer features geared specifically for interactive use rather than to augment the programming language. These interactive features include job control, command line editing, command history and aliases.<br>相比作为一种编程语言，shell 多用于交互，她包括了工作控制、命令行编辑等特点。</p><h2 id="Definitions-定义解释"><a href="#Definitions-定义解释" class="headerlink" title="Definitions 定义解释"></a>Definitions 定义解释</h2><div class="table-container"><table><thead><tr><th style="text-align:center">name</th><th style="text-align:center">description</th></tr></thead><tbody><tr><td style="text-align:center"><strong>POSIX</strong></td><td style="text-align:center">A family of open system standards based on Unix. Bash is primarily concerned with the Shell and Utilities portion of the posix 1003.1 standard.</td></tr><tr><td style="text-align:center"><strong>blank</strong></td><td style="text-align:center">A space or tab character.</td></tr><tr><td style="text-align:center"><strong>builtin</strong></td><td style="text-align:center">A command that is implemented internally by the shell itself, rather than by an executable program somewhere in the file system.（shell 内建的命令。）</td></tr><tr><td style="text-align:center"><strong>control operator</strong></td><td style="text-align:center">A token that performs a control function. It is a newline or one of the following: &#124;&#124;, &#38;&#38;;, &#38;, ;, ;;, ;&#38;, ;;&#38;, &#124;, &#124;&amp;, (, or ).</td></tr><tr><td style="text-align:center"><strong>exit status</strong></td><td style="text-align:center">The value returned by a command to its caller. The value is restricted to eight bits, so the maximum value is 255. 命令返回给调用者的值，该值被限制为八位，即其最大值为255。</td></tr><tr><td style="text-align:center"><strong>field</strong></td><td style="text-align:center">A unit of text that is the result of one of the shell expansions. After expansion, when  executing a command, the resulting fields are used as the command name and arguments.</td></tr><tr><td style="text-align:center"><strong>filename</strong></td><td style="text-align:center">A string of characters used to identify a file.</td></tr><tr><td style="text-align:center"><strong>job</strong></td><td style="text-align:center">A set of processes comprising a pipeline, and any processes descended from it, that are all in the same process group.</td></tr><tr><td style="text-align:center"><strong>job control</strong></td><td style="text-align:center">A mechanism by which users can selectively stop (suspend) and restart (resume) execution of processes.</td></tr><tr><td style="text-align:center"><strong>metacharacter</strong></td><td style="text-align:center">A character that, when unquoted, separates words. A metacharacter is a <em>space</em>, <em>tab</em>, <em>newline</em>, or one of the following characters: &#124;, &#38;, ;, (, ), &#60;, or &#62;.</td></tr><tr><td style="text-align:center"><strong>元字符</strong></td><td style="text-align:center">在不带引号时可以用于分离词，可以是空格，制表符，换行或者&#124;, &#38;, ;, (, ), &#60;, &#62;。</td></tr><tr><td style="text-align:center"><strong>name（标识符）</strong></td><td style="text-align:center">A word consisting solely of letters, numbers, and underscores, and beginning with a letter or underscore. Names are used as shell variable and function names. Also referred to as an identifier. （由字母、数字和下划线组成，以字母或下划线开头的词，常用于 shell 变量和函数名。）</td></tr><tr><td style="text-align:center"><strong>operator</strong></td><td style="text-align:center">A control operator or a redirection operator. 控制符或重定向符</td></tr><tr><td style="text-align:center"><strong>process group（进程组）</strong></td><td style="text-align:center">A collection of related processes each having the same process group id. （一组相关的进程，具有相同的进程组id。）</td></tr><tr><td style="text-align:center"><strong>process group ID</strong></td><td style="text-align:center">A unique identifier that represents a process group during its lifetime. （在进程组的生命周期中，用于唯一标识该进程组的标识符。）</td></tr><tr><td style="text-align:center"><strong>reserved word</strong></td><td style="text-align:center">A word that has a special meaning to the shell. Most reserved words introduce shell flow control constructs, such as <code>for</code> and <code>while</code>. （具有特殊含义的词，多用于控制流结构，如 <code>for</code>, <code>while</code>。）</td></tr><tr><td style="text-align:center"><strong>return status</strong></td><td style="text-align:center">A synonym for exit status.</td></tr><tr><td style="text-align:center"><strong>signal（信号）</strong></td><td style="text-align:center">A mechanism by which a process may be notified by the kernel of an event occurring in the system. （使得进程在运行时能被内核通知的机制。）</td></tr><tr><td style="text-align:center"><strong>special builtin</strong></td><td style="text-align:center">A shell builtin command that has been classified as special by the posix standard.</td></tr><tr><td style="text-align:center"><strong>token（句柄)</strong></td><td style="text-align:center">A sequence of characters considered a single unit by the shell. It is either a word or an operator. （在一条句子中被 shell 认为有意义的最小部分，可以是一个词或一个运算符。）</td></tr><tr><td style="text-align:center"><strong>word</strong></td><td style="text-align:center">A sequence of characters treated as a unit by the shell. Words may not include unquoted metacharacters.（一段被 shell 作为单个单元处理的字符，不能包括未带引号的元字符。）</td></tr></tbody></table></div><h2 id="Basic-Shell-Features-基本的-shell-特性"><a href="#Basic-Shell-Features-基本的-shell-特性" class="headerlink" title="Basic Shell Features 基本的 shell 特性"></a>Basic Shell Features 基本的 shell 特性</h2><p>This chapter briefly summarizes the shell’s ‘building blocks’: commands, control structures, shell functions, shell parameters, shell expansions, redirections, which are a way to direct input and output from and to named files, and how the shell executes commands.</p><p>本章简要地介绍 shell 被用于向文件输入输出的内建模块：命令、控制结构、函数、参数、扩展和重定向，以及解释 shell 如何执行命令。</p><h3 id="Shell-Syntax-Shell-语法"><a href="#Shell-Syntax-Shell-语法" class="headerlink" title="Shell Syntax Shell 语法"></a>Shell Syntax Shell 语法</h3><p>When the shell reads input, it proceeds through a sequence of operations. If the input indicates the beginning of a comment, the shell ignores the comment symbol (‘#’), and the rest of that line. </p><p>Otherwise, roughly speaking, the shell reads its input and divides the input into words and operators, employing the quoting rules to select which meanings to assign various words and characters. </p><p>The shell then parses these tokens into commands and other constructs, removes the special meaning of certain words or characters, expands others, redirects input and output as needed, executes the specified command, waits for the command’s exit status, and makes that exit status available for further inspection or processing. </p><h4 id="Shell-Operation"><a href="#Shell-Operation" class="headerlink" title="Shell Operation"></a>Shell Operation</h4><p>The following is a brief description of the shell’s operation when it reads and executes a command. Basically, the shell does the following:</p><ol><li><p>Reads its input from a file, from a string supplied as an argument to the -c invocation option, or from the user’s terminal. </p></li><li><p>Breaks the input into words and operators, obeying the quoting rules. These tokens are separated by metacharacters. Alias expansion is performed by this step.</p></li><li>Parses the tokens into simple and compound commands. </li><li>Performs the various shell expansions, breaking the expanded tokens into lists of filenames and commands and arguments. </li><li>Performs any necessary redirections and removes the redirection operators and their operands from the argument list. </li><li>Executes the command. </li><li>Optionally waits for the command to complete and collects its exit status.  </li></ol><h4 id="Quoting-引用"><a href="#Quoting-引用" class="headerlink" title="Quoting 引用"></a>Quoting 引用</h4><p>Quoting is used to remove the special meaning of certain characters or words to the shell. Quoting can be used to disable special treatment for special characters, to prevent reserved words from being recognized as such, and to prevent parameter expansion. </p><p>引用常被用于消歧义，移除保留字的特殊意义（转义）等。</p><p>Each of the shell metacharacters has special meaning to the shell and must be quoted if it is to represent itself. When the command history expansion facilities are being used, the history expansion character, usually ‘!’, must be quoted to prevent history expansion. </p><p>shell 中有三种引用机制：反斜杠、单引号和双引号。</p><h5 id="Escape-Character-反斜杠"><a href="#Escape-Character-反斜杠" class="headerlink" title="Escape Character 反斜杠"></a>Escape Character 反斜杠</h5><p>A non-quoted backslash ‘\’ is the Bash escape character. It preserves the literal value of the next character that follows, with the exception of newline. If a \newline pair appears, and the backslash itself is not quoted, the \newline is treated as a line continuation (that is, it is removed from the input stream and effectively ignored).</p><p>未引用的反斜杠将被用于转义，除了一种特殊情况：若反斜杠后跟换行符，将被视为该行的继续（也就是说，在输入流中，反斜杠会被移除）。</p><h5 id="Single-Quotes-单引号"><a href="#Single-Quotes-单引号" class="headerlink" title="Single Quotes 单引号"></a>Single Quotes 单引号</h5><p>Enclosing characters in single quotes (‘’’) preserves the literal value of each character within<br>the quotes. A single quote may not occur between single quotes, even when preceded by a<br>backslash.</p><h5 id="Double-Quotes-双引号"><a href="#Double-Quotes-双引号" class="headerlink" title="Double Quotes 双引号"></a>Double Quotes 双引号</h5><p>Enclosing characters in double quotes (‘<code>&quot;</code>’) preserves the literal value of all characters within<br>the quotes, with the exception of ‘<code>$</code>’, ‘<code>‘</code>’, ‘<code>\</code>’, and, when history expansion is enabled, ‘<code>!</code>’.</p><ul><li><p>When the shell is in <code>posix</code> mode, the ‘<code>!</code>’ has no special meaning within double quotes, even when history expansion is enabled.</p></li><li><p>The characters ‘<code>$</code>’ and ‘<code>‘</code>’ retain their special meaning within double quotes.</p></li><li><p>The backslash retains its special meaning only when followed by one of the following characters: ‘<code>$</code>’, ‘<code>‘</code>’, ‘<code>&quot;</code>’, ‘<code>\</code>’, or <code>newline</code>. Within double quotes, backslashes that are followed by one of these characters are removed. Backslashes preceding characters without a special meaning are left unmodified.</p></li><li><p>A double quote may be quoted within double quotes by preceding it with a backslash. If enabled, history expansion will be performed unless an ‘<code>!</code>’ appearing in double quotes is escaped using a backslash. The backslash preceding the ‘<code>!</code>’ is not removed. </p></li><li><p>The special parameters ‘<code>*</code>’ and ‘<code>@</code>’ have special meaning when in double quotes, (see [Shell Parameter Expansion]). </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cypher</title>
      <link href="/2019/04/10/Cypher/"/>
      <url>/2019/04/10/Cypher/</url>
      
        <content type="html"><![CDATA[<h2 id="Prologue"><a href="#Prologue" class="headerlink" title="Prologue"></a>Prologue</h2><p>Cypher begins with a section, it’s from <em>Alice’s Adventures in Wonderland</em>, </p><img src="/2019/04/10/Cypher/Firstpuzzle.jpg" title="First puzzle in Cypher">]]></content>
      
      
      <categories>
          
          <category> miscellaneous </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Game review </tag>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My gitlearning notes</title>
      <link href="/2019/02/03/gitLearning/"/>
      <url>/2019/02/03/gitLearning/</url>
      
        <content type="html"><![CDATA[<h2 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><ol><li>选择一个合适的目录（最好是空目录），通过<code>git init</code>将其变为Git可以管理的仓库：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>其中<code>.git</code>目录是Git用于跟踪管理版本库的，<strong>没事千万不要手动修改这个目录里的文件</strong>。</p><ol><li>用<code>git add</code>将文件添加到仓库：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><ol><li>用<code>git commit -m &lt;message&gt;</code>将文件提交到仓库：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"wrote a readme file"</span></span><br></pre></td></tr></table></figure><p><code>-m</code>后面输入本次提交的说明，<code>commit</code>一次可以提交很多文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m <span class="string">"add 3 files."</span></span><br></pre></td></tr></table></figure><h3 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h3><ul><li>随时掌握工作区状态，使用<code>git status</code>命令</li><li>如果<code>git status</code>告诉你文件被修改过，用<code>git diff</code>查看修改内容</li></ul><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><ul><li><code>git log</code>查看版本历史记录，如果觉得输出信息太多，加上<code>--pretty=oneline</code></li><li><code>HEAD</code>是一个指向当前版本的指针，<code>HEAD</code>表示当前版本，<code>HEAD^</code>表示上一个版本，<code>HEAD^^</code>表示上上个版本…<code>HEAD-100</code>表示前100个版本</li><li><code>git reset</code>回退：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>回退到了上个版本，若要撤销这次更改，返回到原来的版本，需要知道那个版本的<code>commit id</code>（的前几位），<strong>最后的办法</strong>是查询Git记录的命令，利用<code>git reflog</code>查找那个版本的<code>commit id</code>。</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><ul><li>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- &lt;filename&gt;</code>。</li><li>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;filename&gt;</code>，再使用<code>git checkout -- &lt;filename&gt;</code>。</li><li>已经提交了不合适的修改到版本库时，想要撤销本次提交，参考上一节，不过前提是没有推送到远程库。</li></ul><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>若使用<code>rm</code>在文件管理器中删除了文件，有以下两种情况：</p><ul><li>确实需要删除这个文件，那么使用<code>git rm &lt;filename&gt;</code>在暂存区内把文件删去，然后<code>git commit</code>。</li><li>卧槽，删错了，见上一节，<code>git checkout -- &lt;filename&gt;</code>撤销修改。</li></ul><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><p>如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>关联远程库，使用<code>git remote add &lt;repositoryname&gt; git@server-name:path/repo-name.git</code>（详情见Github提示，库名默认为<code>origin</code>）。</p><p>关联后，使用命令<code>git push -u origin master</code><strong>第一次</strong>推送<code>master</code>分支的所有内容，此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改，其中，<code>origin</code>是默认的库名。</p><h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><p>使用<code>git clone</code>命令克隆，Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git</code>协议速度最快。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p><code>HEAD</code>严格来说并不是指向提交，而是指向当前分支，<code>master</code>才指向提交。不同的人在进行同一个项目的开发时，需要建立分支，工作完成后，就需要把分支合并到<code>master</code>上，Git的合并和删除分支实质上就是指针的修改和删除。</p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><ul><li>使用<code>git checkout -b &lt;branchname&gt;</code>创建并切换到分支。它相当于：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch &lt;branchname&gt;</span><br><span class="line">$ git checkout &lt;branchname&gt;</span><br></pre></td></tr></table></figure><ul><li>使用<code>git branch</code>查看所有分支，当前分支的前面会有一个星号*。</li><li>使用<code>git checkout &lt;branchname&gt;</code>切换分支。</li><li>使用<code>git merge &lt;branchname&gt;</code>将要合并的分支合并到<code>master</code>分支上。</li><li>使用<code>git branch -d &lt;branchname&gt;</code>删除分支</li><li>当Git无法自动合并分支时，就必须首先解决冲突，将冲突的文件<strong>统一</strong>修改为我们希望的内容，然后提交。解决冲突的步骤是：查看冲突文件（<code>cat &lt;filename&gt;</code>，Git会给予提示），编辑冲突文件（Git已在冲突文件中写入改动情况），提交，最后删去非<code>master</code>的分支。</li><li>使用<code>git log --graph</code>查看合并分支图。使用<code>git log --graph --pretty=oneline --abbrev-commit</code>更方便查看。</li></ul><h3 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h3><p>合并分支时，加上<code>--no-ff</code>就可以用普通模式合并，合并后存在历史分支，而Git默认的<code>fast forward</code>会删去历史分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m <span class="string">"something"</span> &lt;branchname&gt;</span><br></pre></td></tr></table></figure><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本。每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p><h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p>手头工作没有完成却要先到别的分支（修复bug时，一般要创建新的<code>issue-xxx</code>分支）上工作时，使用<code>git stash</code>，再切换到别的分支工作，工作结束后，通过<code>git stash pop</code>恢复stash内容并删除原来的stash内容。若不想删去stash内容，使用<code>git stash apply stash@{number}</code>，日后再通过<code>git stash drop</code>删除。<code>git stash pop</code>和<code>git stash drop</code>删除的都是最新的一个stash。</p><p>通过<code>git stash list</code>查看stash 内容。</p><h3 id="feature分支"><a href="#feature分支" class="headerlink" title="feature分支"></a>feature分支</h3><p>开发一个新的feature，最好新建一个分支，如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin &lt;branchname&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branchname&gt; origin/&lt;branchname&gt;</code>。</p><ul><li>查看远程库，使用<code>git remote -v</code>；</li><li>本地新建的分支如果不推送到远程，对他人就是不可见的；</li><li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li><li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li></ul><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p><code>git rebase</code>可以把本地未push的分叉提交历史管理整理成直线，目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。缺点是本地的分叉提交已经被修改过了。</p><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针，标签是一个让人容易记住的名字（如版本号v1.0），而不是像<code>commit id</code>一样的字符串。</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><ul><li><code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认commit为<code>HEAD</code>，也可以用<code>commit id</code>指定一个commit。</li><li>命令<code>git tag -a &lt;tagname&gt; -m &quot;something...&quot;</code>可以指定标签信息；</li><li>命令<code>git tag</code>可以查看所有标签，<code>git show &lt;tagname&gt;</code>查看标签信息。</li></ul><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><ul><li><code>git push origin &lt;tagname&gt;</code>推送一个本地标签；</li><li><code>git push origin --tags</code>推送全部未推送过的本地标签；</li><li><code>git tag -d &lt;tagname&gt;</code>删除一个本地标签；</li><li><code>git push origin :refs/tags/&lt;tagname&gt;</code>删除一个远程标签。</li></ul><h2 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h2><p>在GitHub上，可以点击<strong>Fork</strong>，这样会在自己的账号下克隆一个相同的仓库，然后通过<code>git clone</code>命令从<strong>自己的</strong>仓库里克隆项目——只有这样才有权限进行读写，然后就可以开始工作。工作结束后，往自己的仓库推送。如果你参与的是别人的项目，可以在GitHub上发起一个<code>pull request</code>。</p><h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global color.ui <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这样，Git会适当地显示不同的颜色。</p><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p>忽略某些文件时，需要加入<code>.gitignore</code>并提交，不需要自己从头编写，可以到以下网站查找：</p><blockquote><p><a href="https://www.gitignore.io/" target="_blank" rel="noopener">https://www.gitignore.io/</a><br><a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p></blockquote><p>检验<code>.gitignore</code>是否符合你的需要的标准是<code>git status</code>命令下是否显示<code>working directory clean</code>。</p><p>忽略文件的原则是：</p><ul><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ul><p>若想添加一个文件到Git，而这个文件却已经被<code>.gitignore</code>忽略，可以强制添加：<code>git add -f &lt;filename&gt;</code>；另一种情况是，<code>.gitignore</code>确实写的有问题，可以用<code>git check-ignore -v &lt;filename&gt;</code>检查该文件。</p><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p><p>每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config </span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = <span class="literal">true</span></span><br><span class="line">    bare = <span class="literal">false</span></span><br><span class="line">    logallrefupdates = <span class="literal">true</span></span><br><span class="line">    ignorecase = <span class="literal">true</span></span><br><span class="line">    precomposeunicode = <span class="literal">true</span></span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">    url = git@github.com:michaelliao/learngit.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">    last = <span class="built_in">log</span> -1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。<br>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitconfig</span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">    co = checkout</span><br><span class="line">    ci = commit</span><br><span class="line">    br = branch</span><br><span class="line">    st = status</span><br><span class="line">[user]</span><br><span class="line">    name = Your Name</span><br><span class="line">    email = your@email.com</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p><h3 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h3><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
