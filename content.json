{"meta":{"title":"Clair de lune","subtitle":"do one thing and do it well","description":null,"author":"St4rg4z3r","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-04-09T12:34:50.000Z","updated":"2019-04-09T12:35:09.564Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-09T12:31:15.000Z","updated":"2019-04-09T12:31:42.166Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"bash - communicating with Miss UNIX","slug":"bash","date":"2019-04-18T03:02:21.000Z","updated":"2019-04-30T03:25:38.180Z","comments":true,"path":"2019/04/18/bash/","link":"","permalink":"http://yoursite.com/2019/04/18/bash/","excerpt":"","text":"Bash is the shell, or command language interpreter, for the gnu operating system. The name is an acronym for the ‘Bourne-Again SHell’, a pun on Stephen Bourne, the author of the direct ancestor of the current Unix shell sh, which appeared in the Seventh Edition Bell Labs Research version of Unix. IntroductionWhat is a shell?At its base, a shell is simply a macro processor that executes commands. The term macro processor means functionality where text and symbols are expanded to create larger expressions. A Unix shell is both a command interpreter and a programming language. Shells may be used interactively or non-interactively. In interactive mode, they accept input typed from the keyboard. When executing non-interactively, shells execute commands read from a file. A shell allows execution of gnu commands, both synchronously and asynchronously. The shell waits for synchronous commands to complete before accepting more input; asynchronous commands continue to execute in parallel with the shell while it reads and executes additional commands. The redirection constructs permit fine-grained control of the input and output of those commands. Moreover, the shell allows control over the contents of commands’ environments. Shells also provide a small set of built-in commands (builtins) implementing functionality impossible or inconvenient to obtain via separate utilities. For example, cd, break, continue, and exec cannot be implemented outside of the shell because they directly manipulate the shell itself. The history, getopts, kill, or pwd builtins, among others, could be implemented in separate utilities, but they are more convenient to use as builtin commands. All of the shell builtins are described in subsequent sections. Shell 提供了小部分内建功能，部分功能在其它程序中可能无法使用。比如：cd, break, continue, exec 不能在 shell 外部使用，因为它们使用的是 shell 本身；history, getopts, kill, pwd 则可以在别的程序中使用，但即便如此，在 shell 中使用他们会更加方便。 While executing commands is essential, most of the power (and complexity) of shells is due to their embedded programming languages. Like any high-level language, the shell provides variables, flow control constructs, quoting, and functions.Shell 内嵌的编程语言非常强大，她提供了变量、控制流、引用和函数等高级语言具有的特性。 Shells offer features geared specifically for interactive use rather than to augment the programming language. These interactive features include job control, command line editing, command history and aliases.相比作为一种编程语言，shell 多用于交互，她包括了工作控制、命令行编辑等特点。 Definitions 定义解释 name description POSIX A family of open system standards based on Unix. Bash is primarily concerned with the Shell and Utilities portion of the posix 1003.1 standard. blank A space or tab character. builtin A command that is implemented internally by the shell itself, rather than by an executable program somewhere in the file system.（shell 内建的命令。） control operator A token that performs a control function. It is a newline or one of the following: &#124;&#124;, &#38;&#38;;, &#38;, ;, ;;, ;&#38;, ;;&#38;, &#124;, &#124;&amp;, (, or ). exit status The value returned by a command to its caller. The value is restricted to eight bits, so the maximum value is 255. 命令返回给调用者的值，该值被限制为八位，即其最大值为255。 field A unit of text that is the result of one of the shell expansions. After expansion, when executing a command, the resulting fields are used as the command name and arguments. filename A string of characters used to identify a file. job A set of processes comprising a pipeline, and any processes descended from it, that are all in the same process group. job control A mechanism by which users can selectively stop (suspend) and restart (resume) execution of processes. metacharacter A character that, when unquoted, separates words. A metacharacter is a space, tab, newline, or one of the following characters: &#124;, &#38;, ;, (, ), &#60;, or &#62;. 元字符 在不带引号时可以用于分离词，可以是空格，制表符，换行或者&#124;, &#38;, ;, (, ), &#60;, &#62;。 name（标识符） A word consisting solely of letters, numbers, and underscores, and beginning with a letter or underscore. Names are used as shell variable and function names. Also referred to as an identifier. （由字母、数字和下划线组成，以字母或下划线开头的词，常用于 shell 变量和函数名。） operator A control operator or a redirection operator. 控制符或重定向符 process group（进程组） A collection of related processes each having the same process group id. （一组相关的进程，具有相同的进程组id。） process group ID A unique identifier that represents a process group during its lifetime. （在进程组的生命周期中，用于唯一标识该进程组的标识符。） reserved word A word that has a special meaning to the shell. Most reserved words introduce shell flow control constructs, such as for and while. （具有特殊含义的词，多用于控制流结构，如 for, while。） return status A synonym for exit status. signal（信号） A mechanism by which a process may be notified by the kernel of an event occurring in the system. （使得进程在运行时能被内核通知的机制。） special builtin A shell builtin command that has been classified as special by the posix standard. token（句柄) A sequence of characters considered a single unit by the shell. It is either a word or an operator. （在一条句子中被 shell 认为有意义的最小部分，可以是一个词或一个运算符。） word A sequence of characters treated as a unit by the shell. Words may not include unquoted metacharacters.（一段被 shell 作为单个单元处理的字符，不能包括未带引号的元字符。） Basic Shell Features 基本的 shell 特性This chapter briefly summarizes the shell’s ‘building blocks’: commands, control structures, shell functions, shell parameters, shell expansions, redirections, which are a way to direct input and output from and to named files, and how the shell executes commands. 本章简要地介绍 shell 被用于向文件输入输出的内建模块：命令、控制结构、函数、参数、扩展和重定向，以及解释 shell 如何执行命令。 Shell Syntax Shell 语法When the shell reads input, it proceeds through a sequence of operations. If the input indicates the beginning of a comment, the shell ignores the comment symbol (‘#’), and the rest of that line. Otherwise, roughly speaking, the shell reads its input and divides the input into words and operators, employing the quoting rules to select which meanings to assign various words and characters. The shell then parses these tokens into commands and other constructs, removes the special meaning of certain words or characters, expands others, redirects input and output as needed, executes the specified command, waits for the command’s exit status, and makes that exit status available for further inspection or processing. Shell OperationThe following is a brief description of the shell’s operation when it reads and executes a command. Basically, the shell does the following: Reads its input from a file, from a string supplied as an argument to the -c invocation option, or from the user’s terminal. Breaks the input into words and operators, obeying the quoting rules. These tokens are separated by metacharacters. Alias expansion is performed by this step. Parses the tokens into simple and compound commands. Performs the various shell expansions, breaking the expanded tokens into lists of filenames and commands and arguments. Performs any necessary redirections and removes the redirection operators and their operands from the argument list. Executes the command. Optionally waits for the command to complete and collects its exit status. Quoting 引用Quoting is used to remove the special meaning of certain characters or words to the shell. Quoting can be used to disable special treatment for special characters, to prevent reserved words from being recognized as such, and to prevent parameter expansion. 引用常被用于消歧义，移除保留字的特殊意义（转义）等。 Each of the shell metacharacters has special meaning to the shell and must be quoted if it is to represent itself. When the command history expansion facilities are being used, the history expansion character, usually ‘!’, must be quoted to prevent history expansion. shell 中有三种引用机制：反斜杠、单引号和双引号。 Escape Character 反斜杠A non-quoted backslash ‘\\’ is the Bash escape character. It preserves the literal value of the next character that follows, with the exception of newline. If a \\newline pair appears, and the backslash itself is not quoted, the \\newline is treated as a line continuation (that is, it is removed from the input stream and effectively ignored). 未引用的反斜杠将被用于转义，除了一种特殊情况：若反斜杠后跟换行符，将被视为该行的继续（也就是说，在输入流中，反斜杠会被移除）。 Single Quotes 单引号Enclosing characters in single quotes (‘’’) preserves the literal value of each character withinthe quotes. A single quote may not occur between single quotes, even when preceded by abackslash. Double Quotes 双引号Enclosing characters in double quotes (‘&quot;’) preserves the literal value of all characters withinthe quotes, with the exception of ‘$’, ‘‘’, ‘\\’, and, when history expansion is enabled, ‘!’. When the shell is in posix mode, the ‘!’ has no special meaning within double quotes, even when history expansion is enabled. The characters ‘$’ and ‘‘’ retain their special meaning within double quotes. The backslash retains its special meaning only when followed by one of the following characters: ‘$’, ‘‘’, ‘&quot;’, ‘\\’, or newline. Within double quotes, backslashes that are followed by one of these characters are removed. Backslashes preceding characters without a special meaning are left unmodified. A double quote may be quoted within double quotes by preceding it with a backslash. If enabled, history expansion will be performed unless an ‘!’ appearing in double quotes is escaped using a backslash. The backslash preceding the ‘!’ is not removed. The special parameters ‘*’ and ‘@’ have special meaning when in double quotes, (see [Shell Parameter Expansion]).","categories":[{"name":"Programming","slug":"Programming","permalink":"http://yoursite.com/categories/Programming/"}],"tags":[{"name":"GNU/Linux","slug":"GNU-Linux","permalink":"http://yoursite.com/tags/GNU-Linux/"}]},{"title":"Cypher","slug":"Cypher","date":"2019-04-10T12:24:15.000Z","updated":"2019-04-10T12:45:37.209Z","comments":true,"path":"2019/04/10/Cypher/","link":"","permalink":"http://yoursite.com/2019/04/10/Cypher/","excerpt":"","text":"PrologueCypher begins with a section, it’s from Alice’s Adventures in Wonderland,","categories":[{"name":"miscellaneous","slug":"miscellaneous","permalink":"http://yoursite.com/categories/miscellaneous/"}],"tags":[{"name":"Game review","slug":"Game-review","permalink":"http://yoursite.com/tags/Game-review/"},{"name":"Cryptography","slug":"Cryptography","permalink":"http://yoursite.com/tags/Cryptography/"}]},{"title":"My gitlearning notes","slug":"gitLearning","date":"2019-02-03T15:33:56.000Z","updated":"2019-04-10T12:36:24.507Z","comments":true,"path":"2019/02/03/gitLearning/","link":"","permalink":"http://yoursite.com/2019/02/03/gitLearning/","excerpt":"","text":"Git基础创建版本库 选择一个合适的目录（最好是空目录），通过git init将其变为Git可以管理的仓库： 1$ git init 其中.git目录是Git用于跟踪管理版本库的，没事千万不要手动修改这个目录里的文件。 用git add将文件添加到仓库： 1$ git add readme.txt 用git commit -m &lt;message&gt;将文件提交到仓库： 1$ git commit -m \"wrote a readme file\" -m后面输入本次提交的说明，commit一次可以提交很多文件： 123$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m \"add 3 files.\" 时光机穿梭 随时掌握工作区状态，使用git status命令 如果git status告诉你文件被修改过，用git diff查看修改内容 版本回退 git log查看版本历史记录，如果觉得输出信息太多，加上--pretty=oneline HEAD是一个指向当前版本的指针，HEAD表示当前版本，HEAD^表示上一个版本，HEAD^^表示上上个版本…HEAD-100表示前100个版本 git reset回退： 1$ git reset --hard HEAD^ 回退到了上个版本，若要撤销这次更改，返回到原来的版本，需要知道那个版本的commit id（的前几位），最后的办法是查询Git记录的命令，利用git reflog查找那个版本的commit id。 撤销修改 当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- &lt;filename&gt;。 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;filename&gt;，再使用git checkout -- &lt;filename&gt;。 已经提交了不合适的修改到版本库时，想要撤销本次提交，参考上一节，不过前提是没有推送到远程库。 删除文件若使用rm在文件管理器中删除了文件，有以下两种情况： 确实需要删除这个文件，那么使用git rm &lt;filename&gt;在暂存区内把文件删去，然后git commit。 卧槽，删错了，见上一节，git checkout -- &lt;filename&gt;撤销修改。 git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 添加远程库关联远程库，使用git remote add &lt;repositoryname&gt; git@server-name:path/repo-name.git（详情见Github提示，库名默认为origin）。 关联后，使用命令git push -u origin master第一次推送master分支的所有内容，此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改，其中，origin是默认的库名。 从远程库克隆使用git clone命令克隆，Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 分支管理HEAD严格来说并不是指向提交，而是指向当前分支，master才指向提交。不同的人在进行同一个项目的开发时，需要建立分支，工作完成后，就需要把分支合并到master上，Git的合并和删除分支实质上就是指针的修改和删除。 合并分支 使用git checkout -b &lt;branchname&gt;创建并切换到分支。它相当于： 12$ git branch &lt;branchname&gt;$ git checkout &lt;branchname&gt; 使用git branch查看所有分支，当前分支的前面会有一个星号*。 使用git checkout &lt;branchname&gt;切换分支。 使用git merge &lt;branchname&gt;将要合并的分支合并到master分支上。 使用git branch -d &lt;branchname&gt;删除分支 当Git无法自动合并分支时，就必须首先解决冲突，将冲突的文件统一修改为我们希望的内容，然后提交。解决冲突的步骤是：查看冲突文件（cat &lt;filename&gt;，Git会给予提示），编辑冲突文件（Git已在冲突文件中写入改动情况），提交，最后删去非master的分支。 使用git log --graph查看合并分支图。使用git log --graph --pretty=oneline --abbrev-commit更方便查看。 分支策略合并分支时，加上--no-ff就可以用普通模式合并，合并后存在历史分支，而Git默认的fast forward会删去历史分支。 1$ git merge --no-ff -m \"something\" &lt;branchname&gt; 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本。每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 Bug分支手头工作没有完成却要先到别的分支（修复bug时，一般要创建新的issue-xxx分支）上工作时，使用git stash，再切换到别的分支工作，工作结束后，通过git stash pop恢复stash内容并删除原来的stash内容。若不想删去stash内容，使用git stash apply stash@{number}，日后再通过git stash drop删除。git stash pop和git stash drop删除的都是最新的一个stash。 通过git stash list查看stash 内容。 feature分支开发一个新的feature，最好新建一个分支，如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。 多人协作多人协作的工作模式通常是这样： 首先，可以试图用git push origin &lt;branchname&gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branchname&gt; origin/&lt;branchname&gt;。 查看远程库，使用git remote -v； 本地新建的分支如果不推送到远程，对他人就是不可见的； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； Rebasegit rebase可以把本地未push的分叉提交历史管理整理成直线，目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。缺点是本地的分叉提交已经被修改过了。 标签管理发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针，标签是一个让人容易记住的名字（如版本号v1.0），而不是像commit id一样的字符串。 创建标签 git tag &lt;tagname&gt;用于新建一个标签，默认commit为HEAD，也可以用commit id指定一个commit。 命令git tag -a &lt;tagname&gt; -m &quot;something...&quot;可以指定标签信息； 命令git tag可以查看所有标签，git show &lt;tagname&gt;查看标签信息。 操作标签 git push origin &lt;tagname&gt;推送一个本地标签； git push origin --tags推送全部未推送过的本地标签； git tag -d &lt;tagname&gt;删除一个本地标签； git push origin :refs/tags/&lt;tagname&gt;删除一个远程标签。 使用GitHub在GitHub上，可以点击Fork，这样会在自己的账号下克隆一个相同的仓库，然后通过git clone命令从自己的仓库里克隆项目——只有这样才有权限进行读写，然后就可以开始工作。工作结束后，往自己的仓库推送。如果你参与的是别人的项目，可以在GitHub上发起一个pull request。 自定义Git1$ git config --global color.ui true 这样，Git会适当地显示不同的颜色。 .gitignore忽略某些文件时，需要加入.gitignore并提交，不需要自己从头编写，可以到以下网站查找： https://www.gitignore.io/https://github.com/github/gitignore 检验.gitignore是否符合你的需要的标准是git status命令下是否显示working directory clean。 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 若想添加一个文件到Git，而这个文件却已经被.gitignore忽略，可以强制添加：git add -f &lt;filename&gt;；另一种情况是，.gitignore确实写的有问题，可以用git check-ignore -v &lt;filename&gt;检查该文件。 配置别名配置Git的时候，加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。 每个仓库的Git配置文件都放在.git/config文件中： 1234567891011121314151617$ cat .git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true[remote \"origin\"] url = git@github.com:michaelliao/learngit.git fetch = +refs/heads/*:refs/remotes/origin/*[branch \"master\"] remote = origin merge = refs/heads/master[alias] last = log -1... 别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中： 12345678910$ cat .gitconfig[alias] co = checkout ci = commit br = branch st = status[user] name = Your Name email = your@email.com... 配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。 搭建Git服务器 https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000","categories":[{"name":"Dev","slug":"Dev","permalink":"http://yoursite.com/categories/Dev/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]}]}